// Copyright (c) 2020 The Orbit Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package orbit_metrics_uploader;

// This proto is used for communication between Orbit and metrics uploader
// client. Changing this proto requires changing the metrics uploader client
// library accordingly.
message OrbitLogEvent {
  // NextID: 24
  enum LogEventType {
    UNKNOWN_EVENT_TYPE = 0;
    // go/keep-sorted start
    ORBIT_CAPTURE_DURATION = 2;
    ORBIT_CAPTURE_END = 17;
    ORBIT_CAPTURE_LOAD = 4;
    ORBIT_CAPTURE_LOAD_V2 = 18;
    ORBIT_CAPTURE_SAVE = 3;
    ORBIT_END_SESSION_CLICKED = 13;
    ORBIT_EXIT = 15;
    ORBIT_INSTANCES_CACHE_HIT = 22;
    ORBIT_INSTANCES_INITIAL_LOAD = 20;
    ORBIT_INSTANCES_LOAD = 21;
    ORBIT_INSTANCE_CONNECT = 19;
    ORBIT_ITERATOR_ADD = 8;
    ORBIT_ITERATOR_REMOVE = 9;
    ORBIT_MAIN_WINDOW_CLOSE = 14;
    ORBIT_MAIN_WINDOW_OPEN = 1;
    ORBIT_METRICS_UPLOADER_START = 10;
    ORBIT_PRESET_DELETE = 7;
    ORBIT_PRESET_LOAD = 6;
    ORBIT_PRESET_SAVE = 5;
    ORBIT_PROJECT_CHANGED = 23;
    ORBIT_SESSION_SETUP_WINDOW_CLOSE = 12;
    ORBIT_SESSION_SETUP_WINDOW_OPEN = 11;
    ORBIT_SYMBOL_LOAD = 16;
    // go/keep-sorted end
  }
  enum StatusCode {
    UNKNOWN_STATUS = 0;

    // The action succeeded.
    SUCCESS = 1;

    // The user explicitly aborted the action via a cancel button.
    CANCELLED = 2;

    // The action failed. This is used for recoverable failures were the user
    // started an action, but Orbit was unable to complete it. This usually
    // means an error message is displayed to the user.
    INTERNAL_ERROR = 3;
  }
  LogEventType log_event_type = 1;

  // OrbitVersion is generated by `git describe --tags --always` command during
  // the build.
  // Format: 1.XX for release version, 1.XX-<suffix> for developer builds.
  string orbit_version = 2;
  // Duration of the log event in milliseconds
  int64 event_duration_milliseconds = 3;
  // Random session identifier
  string session_uuid = 4;
  // Status code of the event
  StatusCode status_code = 5;
  // Detailed information about a capture. Sent with ORBIT_CAPTURE_END.
  OrbitCaptureData orbit_capture_data = 6;
}

// Holds data about a capture taken in Orbit. This includes data that was
// available before the capture start, like the number of dynamically
// instrumented functions and information that is available at capture stop,
// like duration of the capture. It is sent when the user stops the capture, or
// when the capture is aborted because of an error.
// NextID: 24
message OrbitCaptureData {
  // Duration of the capture in milliseconds. This is a measure of time from
  // when the user started a capture until the user ends it.
  int64 duration_in_milliseconds = 1;

  // Number of functions the user dynamically instrumented (hooked) before the
  // start of this capture. This does not include functions that are
  // instrumented via the manual instrumentation api (Orbit.h).
  int64 number_of_instrumented_functions = 2;

  // Number of frame tracks the user added before the start of this capture.
  int64 number_of_frame_tracks = 3;

  // Total number of timers from orbit_api::Start() calls.
  int64 number_of_manual_start_timers = 4;

  // Total number of timers from orbit_api::Stop() calls.
  int64 number_of_manual_stop_timers = 5;

  // Total number of timers from orbit_api::StartAsync() calls.
  int64 number_of_manual_start_async_timers = 6;

  // Total number of timers from orbit_api::StopAsync() calls.
  int64 number_of_manual_stop_async_timers = 7;

  // Number of orbit_api::TrackValue calls that Orbit found in the modules that
  // have been manually instrumented.
  int64 number_of_manual_tracked_values = 8;

  // Whether the collection of thread states is enabled or not.
  enum ThreadStates {
    THREAD_STATES_UNKNOWN = 0;
    THREAD_STATES_ENABLED = 1;
    THREAD_STATES_DISABLED = 2;
  }
  ThreadStates thread_states = 9;

  // Memory information sampling period in milliseconds. The default value 0
  // cannot be chosen by the user, hence it indicates the field was not set.
  // Value -1 means memory information collection is turned off.
  int64 memory_information_sampling_period_ms = 10;

  // Total number of timers of all dynamically instrumented (hooked) functions
  // that were recorded in this capture. This does not include anything from
  // the manual instrumentation api (Orbit.h).
  int64 number_of_instrumented_function_timers = 11;

  // Total number of timers of type kGpuActivity.
  int64 number_of_gpu_activity_timers = 12;

  // Whether the custom Orbit Vulkan layer (libOrbitVulkanLayer.so) was loaded
  // by the process or not.
  enum LibOrbitVulkanLayer {
    LIB_ORBIT_VULKAN_LAYER_UNKNOWN = 0;
    LIB_LOADED = 1;
    LIB_NOT_LOADED = 2;
  }
  LibOrbitVulkanLayer lib_orbit_vulkan_layer = 13;

  // Total number of timers of type kGpuCommandBuffer. Only applicable if
  // loaded_lib_orbit_vulkan_layer is LIB_LOADED.
  int64 number_of_vulkan_layer_gpu_command_buffer_timers = 14;

  // Total number of timers of type kGpuDebugBuffer. Only applicable if
  // lib_orbit_vulkan_layer_loaded is LIB_LOADED.
  int64 number_of_vulkan_layer_gpu_debug_marker_timers = 15;

  // Whether or not the user enabled the limit for local marker depth per
  // command buffer. When this is LIMITED, it means the user checked the option
  // to limit the marker depth.
  enum LocalMarkerDepthPerCommandBuffer {
    LOCAL_MARKER_DEPTH_PER_COMMAND_BUFFER_UNKNOWN = 0;
    LIMITED = 1;
    UNLIMITED = 2;
  }
  LocalMarkerDepthPerCommandBuffer local_marker_depth_per_command_buffer = 16;

  // Value of the limit the user set for local marker depth per command buffer.
  // Only applicable if local_marker_depth_per_command_buffer is LIMITED.
  uint64 max_local_marker_depth_per_command_buffer = 17;

  // Number of orbit_api::Start calls that Orbit found in the modules that have
  // been manually instrumented.
  int64 number_of_manual_start_functions = 18;

  // Number of orbit_api::Stop calls that Orbit found in the modules that have
  // been manually instrumented.
  int64 number_of_manual_stop_functions = 19;

  // Number of orbit_api::StartAsync calls that Orbit found in the modules that
  // have been manually instrumented.
  int64 number_of_manual_start_async_functions = 20;

  // Number of orbit_api::StopAsync calls that Orbit found in the modules that
  // have been manually instrumented.
  int64 number_of_manual_stop_async_functions = 21;

  // Total number of timers from manually tracked values.
  int64 number_of_manual_tracked_value_timers = 22;

  // Size of the capture file in bytes.
  uint64 file_size = 23;

  // Method for dynamic instrumentation.
  enum DynamicInstrumentationMethod {
    DYNAMIC_INSTRUMENTATION_METHOD_UNKNOWN = 0;
    DYNAMIC_INSTRUMENTATION_METHOD_KERNEL = 1;
    DYNAMIC_INSTRUMENTATION_METHOD_ORBIT = 2;
  }
  DynamicInstrumentationMethod dynamic_instrumentation_method = 24;

  // Callstack samples per second. A value of 0 means memory callstack sampling
  // was turned off.
  uint64 callstack_samples_per_second = 25;

  // Method used for callstack unwinding.
  enum CallstackUnwindingMethod {
    CALLSTACK_UNWINDING_METHOD_UNKNOWN = 0;
    CALLSTACK_UNWINDING_METHOD_DWARF = 1;
    CALLSTACK_UNWINDING_METHOD_FRAME_POINTER = 2;
  }
  CallstackUnwindingMethod callstack_unwinding_method = 26;
}